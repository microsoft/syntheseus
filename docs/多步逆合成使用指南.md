# Syntheseus å¤šæ­¥é€†åˆæˆä½¿ç”¨æŒ‡å—

## ç›®å½•

- [ç®€ä»‹](#ç®€ä»‹)
- [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
- [æ ¸å¿ƒç»„ä»¶](#æ ¸å¿ƒç»„ä»¶)
  - [å•æ­¥ååº”æ¨¡å‹](#å•æ­¥ååº”æ¨¡å‹)
  - [åŸæ–™åº“ç®¡ç†](#åŸæ–™åº“ç®¡ç†)
  - [æœç´¢ç®—æ³•](#æœç´¢ç®—æ³•)
- [å®Œæ•´å·¥ä½œæµç¨‹](#å®Œæ•´å·¥ä½œæµç¨‹)
- [è¯„æµ‹ä¸åˆ†æ](#è¯„æµ‹ä¸åˆ†æ)
- [é«˜çº§ç”¨æ³•](#é«˜çº§ç”¨æ³•)
- [å‘½ä»¤è¡Œå·¥å…·](#å‘½ä»¤è¡Œå·¥å…·)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

---

## ç®€ä»‹

**Syntheseus** æ˜¯ä¸€ä¸ªç”¨äºç«¯åˆ°ç«¯é€†åˆæˆè§„åˆ’çš„ Python åŒ…ï¼Œå®ƒå°†ååº”æ¨¡å‹å’Œæœç´¢ç®—æ³•ä»¥æ ‡å‡†åŒ–çš„æ–¹å¼ç»„åˆåœ¨ä¸€èµ·ã€‚

### ä¸»è¦ç‰¹æ€§

- âš’ï¸ **æ ‡å‡†åŒ–æ¥å£**: ç»Ÿä¸€çš„APIè®©ä½ è½»æ¾åˆ‡æ¢æ¨¡å‹å’Œç®—æ³•
- ğŸ§­ **å¤šç§æœç´¢ç®—æ³•**: Retro*, MCTS, PDVN, BFSç­‰
- ğŸ§ª **æœ€å…ˆè¿›æ¨¡å‹**: é¢„é›†æˆLocalRetro, Chemformer, MEGANç­‰
- âš™ï¸ **é«˜åº¦å¯æ‰©å±•**: è½»æ¾æ’å…¥è‡ªå®šä¹‰æ¨¡å‹å’Œç®—æ³•
- ğŸ“ˆ **å®Œæ•´è¯„æµ‹**: å†…ç½®å¤šç§è¯„æµ‹æŒ‡æ ‡å’Œå¯è§†åŒ–å·¥å…·

### é€‚ç”¨åœºæ™¯

- ğŸ”¬ **è¯ç‰©å‘ç°**: è§„åˆ’æ–°è¯åˆ†å­çš„åˆæˆè·¯çº¿
- ğŸ§¬ **ææ–™ç§‘å­¦**: è®¾è®¡æ–°ææ–™çš„åˆæˆæ–¹æ¡ˆ
- ğŸ“Š **ç®—æ³•ç ”ç©¶**: æ¯”è¾ƒå’Œè¯„æµ‹ä¸åŒçš„é€†åˆæˆç®—æ³•
- ğŸ“ **æ•™å­¦**: å­¦ä¹ é€†åˆæˆè§„åˆ’çš„åŸç†å’Œæ–¹æ³•

---

## å¿«é€Ÿå¼€å§‹

### å®‰è£…

```bash
# å®Œæ•´å®‰è£…ï¼ˆæ¨èï¼‰
conda env create -f environment_full.yml
conda activate syntheseus-full
pip install "syntheseus[all]"

# æˆ–è€…æœ€å°åŒ–å®‰è£…
pip install syntheseus
```

### 5åˆ†é’Ÿç¤ºä¾‹

```python
from syntheseus import Molecule
from syntheseus.reaction_prediction.inference import LocalRetroModel
from syntheseus.search.mol_inventory import SmilesListInventory
from syntheseus.search.algorithms.breadth_first import AndOr_BreadthFirstSearch

# 1. åˆå§‹åŒ–å•æ­¥æ¨¡å‹
model = LocalRetroModel(use_cache=True, default_num_results=50)

# 2. è®¾ç½®åŸæ–™åº“
inventory = SmilesListInventory(smiles_list=[
    "Cc1ccc(B(O)O)cc1",
    "Cc1ccc(Br)cc1",
])

# 3. é…ç½®æœç´¢ç®—æ³•
search_alg = AndOr_BreadthFirstSearch(
    reaction_model=model,
    mol_inventory=inventory,
    limit_iterations=100,
    time_limit_s=60.0
)

# 4. è¿è¡Œæœç´¢
target = Molecule("Cc1ccc(-c2ccc(C)cc2)cc1")
output_graph, _ = search_alg.run_from_mol(target)

# 5. æå–ç»“æœ
from syntheseus.search.analysis.route_extraction import iter_routes_time_order
routes = list(iter_routes_time_order(output_graph, max_routes=10))
print(f"æ‰¾åˆ° {len(routes)} æ¡åˆæˆè·¯å¾„")
```

---

## æ ¸å¿ƒç»„ä»¶

### å•æ­¥ååº”æ¨¡å‹

å•æ­¥ååº”æ¨¡å‹è´Ÿè´£é¢„æµ‹ç»™å®šäº§ç‰©çš„å¯èƒ½å‰ä½“ã€‚

#### å¯ç”¨æ¨¡å‹

| æ¨¡å‹ | ç±»å | ç‰¹ç‚¹ | è®­ç»ƒæ•°æ® |
|------|------|------|---------|
| **LocalRetro** | `LocalRetroModel` | åŸºäºæ¨¡æ¿ï¼Œå¿«é€Ÿå‡†ç¡® | USPTO-50K |
| **Chemformer** | `ChemformerModel` | Transformerï¼Œæ³›åŒ–èƒ½åŠ›å¼º | USPTO-MIT |
| **MEGAN** | `MEGANModel` | å›¾ç¼–è¾‘ï¼Œå¹³è¡¡æ€§èƒ½ | USPTO-50K |
| **MHNreact** | `MHNreactModel` | åˆ†å­è¶…å›¾ç½‘ç»œ | USPTO-50K |
| **Graph2Edits** | `Graph2EditsModel` | å›¾åˆ°ç¼–è¾‘è½¬æ¢ | USPTO-50K |
| **RetroKNN** | `RetroKNNModel` | åŸºäºæ£€ç´¢ | USPTO-50K |
| **RootAligned** | `RootAlignedModel` | æ ¹å¯¹é½æ¨¡æ¿ | USPTO-50K |

#### ä½¿ç”¨æ–¹æ³•

```python
from syntheseus.reaction_prediction.inference import LocalRetroModel

# åŸºæœ¬åˆå§‹åŒ–
model = LocalRetroModel()

# é«˜çº§é…ç½®
model = LocalRetroModel(
    model_dir="/path/to/checkpoint",  # è‡ªå®šä¹‰æ¨¡å‹è·¯å¾„
    use_cache=True,                    # å¯ç”¨ç¼“å­˜
    default_num_results=50,            # æ¯æ¬¡è¿”å›ç»“æœæ•°
    batch_size=32,                     # æ‰¹å¤„ç†å¤§å°
)

# é¢„æµ‹
from syntheseus import Molecule
mol = Molecule("Cc1ccc(-c2ccc(C)cc2)cc1")
[results] = model([mol], num_results=10)

for rxn in results:
    print(f"ååº”ç‰©: {[r.smiles for r in rxn.reactants]}")
    print(f"æ¦‚ç‡: {rxn.metadata.get('probability', 'N/A')}")
```

#### æ¨¡å‹æ€§èƒ½æ¯”è¾ƒ

åŸºäº USPTO-50K æµ‹è¯•é›†çš„ Top-10 å‡†ç¡®ç‡ï¼š

- LocalRetro: ~54%
- Chemformer: ~51%
- MEGAN: ~48%
- MHNreact: ~52%

ï¼ˆæ³¨æ„ï¼šæ€§èƒ½å¯èƒ½å› è®­ç»ƒè®¾ç½®å’Œè¯„æµ‹æ–¹æ³•è€Œå¼‚ï¼‰

---

### åŸæ–™åº“ç®¡ç†

åŸæ–™åº“å®šä¹‰äº†å“ªäº›åˆ†å­å¯ä»¥ç›´æ¥è´­ä¹°ï¼Œä¸éœ€è¦è¿›ä¸€æ­¥åˆæˆã€‚

#### ä» SMILES åˆ—è¡¨åˆ›å»º

```python
from syntheseus.search.mol_inventory import SmilesListInventory

inventory = SmilesListInventory(
    smiles_list=[
        "Cc1ccc(Br)cc1",
        "Ic1ccccc1",
        "B(O)(O)c1ccccc1",
    ],
    canonicalize=True  # è‡ªåŠ¨è§„èŒƒåŒ– SMILES
)

print(f"åŸæ–™åº“å¤§å°: {len(inventory)}")
```

#### ä»æ–‡ä»¶åŠ è½½

```python
# building_blocks.txt æ ¼å¼ï¼šæ¯è¡Œä¸€ä¸ª SMILES
inventory = SmilesListInventory.load_from_file(
    "building_blocks.txt",
    canonicalize=True
)
```

#### æ£€æŸ¥åˆ†å­æ˜¯å¦å¯è´­ä¹°

```python
from syntheseus import Molecule

mol = Molecule("Cc1ccc(Br)cc1")
is_purchasable = inventory.is_purchasable(mol)
print(f"{mol.smiles} å¯è´­ä¹°: {is_purchasable}")
```

#### ä½¿ç”¨å•†ä¸šåŸæ–™åº“

ä½ å¯ä»¥ä½¿ç”¨å®é™…çš„å•†ä¸šåŸæ–™åº“ï¼Œä¾‹å¦‚ï¼š

- **Sigma-Aldrich**: ~30ä¸‡ç§åŒ–åˆç‰©
- **Enamine REAL**: æ•°åäº¿ç§å¯åˆæˆåŒ–åˆç‰©
- **eMolecules**: ~500ä¸‡ç§åŒ–åˆç‰©
- **ZINC**: æ•°äº¿ç§åŒ–åˆç‰©

åªéœ€å°†è¿™äº›åº“å¯¼å‡ºä¸º SMILES æ–‡ä»¶å³å¯ã€‚

---

### æœç´¢ç®—æ³•

æœç´¢ç®—æ³•è´Ÿè´£æ¢ç´¢åˆæˆç©ºé—´ï¼Œæ‰¾åˆ°ä»åŸæ–™åº“åˆ°ç›®æ ‡åˆ†å­çš„è·¯å¾„ã€‚

#### Retro* (æ¨èç”¨äºå¯»æ‰¾æœ€ä¼˜è·¯å¾„)

**åŸç†**: æœ€ä¼˜ä¼˜å…ˆæœç´¢ï¼Œä½¿ç”¨å¯å‘å¼å‡½æ•°æŒ‡å¯¼æœç´¢æ–¹å‘ã€‚

**ä¼˜ç‚¹**:
- å¯ä»¥æ‰¾åˆ°æœ€ä¼˜æˆ–è¿‘æœ€ä¼˜è·¯å¾„
- ç†è®ºä¿è¯å®Œå¤‡æ€§
- æ•ˆç‡é«˜

**ç¼ºç‚¹**:
- éœ€è¦è‰¯å¥½çš„å¯å‘å¼å‡½æ•°
- å¯èƒ½è¿‡åº¦å…³æ³¨å•ä¸€è·¯å¾„

**é…ç½®ç¤ºä¾‹**:

```python
from syntheseus.search.algorithms.best_first.retro_star import RetroStarSearch
from syntheseus.search.algorithms.best_first import retro_star
from syntheseus.search.node_evaluation.common import (
    ConstantNodeEvaluator,
    ReactionModelLogProbCost
)

# é…ç½®æˆæœ¬å‡½æ•°
or_node_cost_fn = retro_star.MolIsPurchasableCost()
and_node_cost_fn = ReactionModelLogProbCost(normalize=False)
value_function = ConstantNodeEvaluator(0.0)  # Retro*-0

# åˆ›å»ºæœç´¢ç®—æ³•
alg = RetroStarSearch(
    reaction_model=model,
    mol_inventory=inventory,
    or_node_cost_fn=or_node_cost_fn,
    and_node_cost_fn=and_node_cost_fn,
    value_function=value_function,
    limit_iterations=100,
    limit_reaction_model_calls=100,
    time_limit_s=60.0,
    max_expansion_depth=10,
)
```

**å…³é”®å‚æ•°**:
- `value_function`: å¯å‘å¼å‡½æ•°ï¼Œä¼°è®¡æœªæ¥æˆæœ¬
  - `ConstantNodeEvaluator(0.0)`: Retro*-0ï¼ˆæœ€ä¹è§‚ï¼‰
  - `ConstantNodeEvaluator(1.0)`: Retro*-1ï¼ˆæ›´ä¿å®ˆï¼‰
- `and_node_cost_fn`: ååº”æˆæœ¬å‡½æ•°
- `or_node_cost_fn`: åˆ†å­æˆæœ¬å‡½æ•°

#### MCTS (æ¨èç”¨äºæ¢ç´¢å¤šæ ·è·¯å¾„)

**åŸç†**: è’™ç‰¹å¡æ´›æ ‘æœç´¢ï¼Œé€šè¿‡éšæœºé‡‡æ ·å¹³è¡¡æ¢ç´¢å’Œåˆ©ç”¨ã€‚

**ä¼˜ç‚¹**:
- å¯ä»¥æ‰¾åˆ°å¤šæ ·åŒ–çš„è·¯å¾„
- ä¸éœ€è¦é¢†åŸŸçŸ¥è¯†
- é€‚åˆå¤§ç©ºé—´æ¢ç´¢

**ç¼ºç‚¹**:
- å¯èƒ½ä¸æ‰¾åˆ°æœ€ä¼˜è§£
- éœ€è¦æ›´å¤šè®¡ç®—èµ„æº

**é…ç½®ç¤ºä¾‹**:

```python
from syntheseus.search.algorithms.mcts.molset import MolSetMCTS
from syntheseus.search.algorithms.mcts.base import pucb_bound
from syntheseus.search.node_evaluation.common import (
    HasSolutionValueFunction,
    ReactionModelProbPolicy
)

# é…ç½® MCTS ç»„ä»¶
reward_function = HasSolutionValueFunction()
value_function = ConstantNodeEvaluator(0.5)
policy = ReactionModelProbPolicy(normalize=True, temperature=3.0)

# åˆ›å»º MCTS
alg = MolSetMCTS(
    reaction_model=model,
    mol_inventory=inventory,
    reward_function=reward_function,
    value_function=value_function,
    policy=policy,
    bound_constant=100.0,
    bound_function=pucb_bound,
    limit_iterations=100,
    time_limit_s=60.0,
    max_expansion_depth=20,
)
```

**å…³é”®å‚æ•°**:
- `reward_function`: å®šä¹‰ç»ˆæ­¢çŠ¶æ€çš„å¥–åŠ±
- `value_function`: ä¼°è®¡çŠ¶æ€ä»·å€¼
- `policy`: åŠ¨ä½œé€‰æ‹©ç­–ç•¥
- `bound_constant`: UCBæ¢ç´¢å¸¸æ•°ï¼ˆè¶Šå¤§è¶Šå€¾å‘æ¢ç´¢ï¼‰
- `temperature`: ç­–ç•¥æ¸©åº¦ï¼ˆè¶Šé«˜è¶Šéšæœºï¼‰

#### BFS (ç®€å•åŸºçº¿)

**åŸç†**: å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ŒæŒ‰å±‚æ¬¡å±•å¼€æ‰€æœ‰èŠ‚ç‚¹ã€‚

**ä¼˜ç‚¹**:
- å®ç°ç®€å•
- å¯ä»¥æ‰¾åˆ°æœ€çŸ­è·¯å¾„
- é€‚åˆä½œä¸ºåŸºçº¿

**ç¼ºç‚¹**:
- æ•ˆç‡è¾ƒä½
- å¯èƒ½å±•å¼€å¤§é‡æ— ç”¨èŠ‚ç‚¹

**é…ç½®ç¤ºä¾‹**:

```python
from syntheseus.search.algorithms.breadth_first import AndOr_BreadthFirstSearch

alg = AndOr_BreadthFirstSearch(
    reaction_model=model,
    mol_inventory=inventory,
    limit_iterations=100,
    time_limit_s=60.0,
)
```

#### PDVN (é«˜çº§)

Policy-Driven Value Networkï¼Œç»“åˆç­–ç•¥å’Œå€¼ç½‘ç»œçš„MCTSå˜ä½“ã€‚

```python
from syntheseus.search.algorithms.pdvn import PDVN_MCTS
# é…ç½®ç±»ä¼¼ MCTSï¼Œä½†éœ€è¦é¢å¤–çš„ cost value function
```

#### ç®—æ³•é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èç®—æ³• | åŸå›  |
|------|---------|------|
| éœ€è¦æœ€ä¼˜è·¯å¾„ | Retro* | æœ‰ç†è®ºä¿è¯ |
| éœ€è¦å¤šæ ·è·¯å¾„ | MCTS | æ¢ç´¢èƒ½åŠ›å¼º |
| å¿«é€ŸåŸå‹ | BFS | ç®€å•ç¨³å®š |
| å¤§è§„æ¨¡æœç´¢ | Retro* | æ•ˆç‡æœ€é«˜ |
| ç ”ç©¶æ–°æ–¹æ³• | è‡ªå®šä¹‰ | æ¡†æ¶çµæ´» |

---

## å®Œæ•´å·¥ä½œæµç¨‹

### æ­¥éª¤1: å‡†å¤‡æ•°æ®

```python
# 1.1 å®šä¹‰ç›®æ ‡åˆ†å­
from syntheseus import Molecule
target = Molecule("COc1ccc(-c2ccc(OC)cc2)cc1")

# 1.2 å‡†å¤‡åŸæ–™åº“
from syntheseus.search.mol_inventory import SmilesListInventory
inventory = SmilesListInventory.load_from_file("building_blocks.txt")

print(f"ç›®æ ‡: {target.smiles}")
print(f"åŸæ–™åº“å¤§å°: {len(inventory)}")
```

### æ­¥éª¤2: é…ç½®æ¨¡å‹å’Œç®—æ³•

```python
# 2.1 åˆå§‹åŒ–æ¨¡å‹
from syntheseus.reaction_prediction.inference import LocalRetroModel
model = LocalRetroModel(use_cache=True, default_num_results=50)

# 2.2 é…ç½®æœç´¢ç®—æ³•
from syntheseus.search.algorithms.best_first.retro_star import RetroStarSearch
from syntheseus.search.algorithms.best_first import retro_star
from syntheseus.search.node_evaluation.common import (
    ConstantNodeEvaluator,
    ReactionModelLogProbCost
)

alg = RetroStarSearch(
    reaction_model=model,
    mol_inventory=inventory,
    or_node_cost_fn=retro_star.MolIsPurchasableCost(),
    and_node_cost_fn=ReactionModelLogProbCost(normalize=False),
    value_function=ConstantNodeEvaluator(0.0),
    limit_iterations=100,
    time_limit_s=60.0,
)
```

### æ­¥éª¤3: è¿è¡Œæœç´¢

```python
import time

print("å¼€å§‹æœç´¢...")
start_time = time.time()

# è¿è¡Œæœç´¢
alg.reset()
output_graph, _ = alg.run_from_mol(target)

elapsed = time.time() - start_time

print(f"æœç´¢å®Œæˆï¼")
print(f"æ—¶é—´: {elapsed:.2f}ç§’")
print(f"æ¢ç´¢èŠ‚ç‚¹æ•°: {len(output_graph)}")
print(f"æ¨¡å‹è°ƒç”¨æ¬¡æ•°: {model.num_calls()}")
```

### æ­¥éª¤4: æå–å’Œåˆ†æç»“æœ

```python
from syntheseus.search.analysis.route_extraction import iter_routes_time_order
from syntheseus.search.graph.and_or import AndNode

# æå–è·¯å¾„
routes = list(iter_routes_time_order(output_graph, max_routes=10))
print(f"\næ‰¾åˆ° {len(routes)} æ¡åˆæˆè·¯å¾„")

# åˆ†ææ¯æ¡è·¯å¾„
for idx, route in enumerate(routes, 1):
    num_reactions = len([n for n in route if isinstance(n, AndNode)])
    print(f"è·¯å¾„ {idx}: {num_reactions} æ­¥ååº”")
```

### æ­¥éª¤5: å¯è§†åŒ–

```python
from syntheseus.search.visualization import visualize_andor

# å¯è§†åŒ–æœ€ä½³è·¯å¾„
if routes:
    visualize_andor(
        output_graph,
        filename="best_route.pdf",
        nodes=routes[0]
    )
    print("è·¯å¾„å·²ä¿å­˜åˆ° best_route.pdf")
```

### æ­¥éª¤6: ä¿å­˜ç»“æœ

```python
import pickle
import json

# ä¿å­˜å®Œæ•´å›¾
with open("search_graph.pkl", "wb") as f:
    pickle.dump(output_graph, f)

# ä¿å­˜ç»Ÿè®¡ä¿¡æ¯
stats = {
    "target": target.smiles,
    "elapsed_time": elapsed,
    "nodes_explored": len(output_graph),
    "routes_found": len(routes),
    "model_calls": model.num_calls(),
}

with open("search_stats.json", "w") as f:
    json.dump(stats, f, indent=2)

print("ç»“æœå·²ä¿å­˜")
```

---

## è¯„æµ‹ä¸åˆ†æ

### é¦–æ¬¡æ±‚è§£æ—¶é—´

```python
from syntheseus.search.analysis.solution_time import get_first_solution_time

# è®¾ç½®æ—¶é—´åº¦é‡ï¼ˆä½¿ç”¨æ¨¡å‹è°ƒç”¨æ¬¡æ•°ï¼‰
for node in output_graph.nodes():
    node.data["analysis_time"] = node.data["num_calls_rxn_model"]

soln_time = get_first_solution_time(output_graph)
print(f"é¦–æ¬¡æ±‚è§£æ—¶é—´ï¼ˆæ¨¡å‹è°ƒç”¨æ¬¡æ•°ï¼‰: {soln_time}")

# æˆ–ä½¿ç”¨wallclockæ—¶é—´
for node in output_graph.nodes():
    node.data["analysis_time"] = (
        node.creation_time - output_graph.root_node.creation_time
    ).total_seconds()

soln_time_wallclock = get_first_solution_time(output_graph)
print(f"é¦–æ¬¡æ±‚è§£æ—¶é—´ï¼ˆç§’ï¼‰: {soln_time_wallclock:.2f}")
```

### è·¯å¾„å¤šæ ·æ€§

```python
from syntheseus.search.analysis import diversity

# å°†è·¯å¾„è½¬æ¢ä¸ºsynthesis_graphæ ¼å¼
route_objects = [
    output_graph.to_synthesis_graph(nodes)
    for nodes in routes
]

# è®¡ç®—packing numberï¼ˆä¸ç›¸äº¤è·¯å¾„æ•°ï¼‰
packing_set = diversity.estimate_packing_number(
    routes=route_objects,
    distance_metric=diversity.reaction_jaccard_distance,
    radius=0.999  # Jaccardè·ç¦»é˜ˆå€¼
)

print(f"ä¸ç›¸äº¤è·¯å¾„æ•°: {len(packing_set)}")
```

### è·¯å¾„æˆæœ¬åˆ†æ

```python
from syntheseus.search.graph.and_or import AndNode

def analyze_route_cost(route, graph):
    """åˆ†æè·¯å¾„çš„å„é¡¹æˆæœ¬"""
    reactions = [n for n in route if isinstance(n, AndNode)]
    
    # æ­¥æ•°
    num_steps = len(reactions)
    
    # æ€»æ¦‚ç‡
    total_prob = 1.0
    for rxn in reactions:
        prob = rxn.data.get("probability", 1.0)
        total_prob *= prob
    
    # åˆ†å­æ•°
    from syntheseus.search.graph.and_or import OrNode
    molecules = [n for n in route if isinstance(n, OrNode)]
    num_mols = len(molecules)
    
    return {
        "steps": num_steps,
        "probability": total_prob,
        "molecules": num_mols,
    }

# åˆ†ææ‰€æœ‰è·¯å¾„
for idx, route in enumerate(routes[:5], 1):
    cost = analyze_route_cost(route, output_graph)
    print(f"è·¯å¾„ {idx}: {cost['steps']}æ­¥, "
          f"æ¦‚ç‡={cost['probability']:.4f}, "
          f"{cost['molecules']}ä¸ªåˆ†å­")
```

### æ‰¹é‡è¯„æµ‹

```python
import pandas as pd

def evaluate_on_dataset(targets, model, inventory, algorithm_class, **alg_kwargs):
    """åœ¨å¤šä¸ªç›®æ ‡ä¸Šè¯„æµ‹"""
    results = []
    
    for target_smiles in targets:
        target = Molecule(target_smiles)
        
        # è¿è¡Œæœç´¢
        alg = algorithm_class(
            reaction_model=model,
            mol_inventory=inventory,
            **alg_kwargs
        )
        
        start_time = time.time()
        alg.reset()
        graph, _ = alg.run_from_mol(target)
        elapsed = time.time() - start_time
        
        # æå–è·¯å¾„
        routes = list(iter_routes_time_order(graph, max_routes=10))
        
        results.append({
            "smiles": target_smiles,
            "solved": len(routes) > 0,
            "time": elapsed,
            "nodes": len(graph),
            "routes": len(routes),
        })
    
    return pd.DataFrame(results)

# æµ‹è¯•æ•°æ®é›†
test_targets = [
    "Cc1ccc(-c2ccc(C)cc2)cc1",
    "COc1ccc(-c2ccc(OC)cc2)cc1",
    # ... æ›´å¤šç›®æ ‡
]

results_df = evaluate_on_dataset(
    test_targets,
    model,
    inventory,
    RetroStarSearch,
    limit_iterations=100,
    time_limit_s=60.0,
)

print(results_df)
print(f"\næ±‚è§£ç‡: {results_df['solved'].mean():.1%}")
print(f"å¹³å‡æ—¶é—´: {results_df['time'].mean():.2f}ç§’")
```

---

## é«˜çº§ç”¨æ³•

### è‡ªå®šä¹‰å€¼å‡½æ•°

```python
from syntheseus.search.node_evaluation.base import NoCacheNodeEvaluator
from syntheseus.search.graph.and_or import OrNode
from typing import Sequence

class MolecularComplexityValueFunction(NoCacheNodeEvaluator):
    """åŸºäºåˆ†å­å¤æ‚åº¦çš„å€¼å‡½æ•°"""
    
    def _evaluate_nodes(
        self,
        nodes: Sequence[OrNode],
        graph=None,
    ) -> list[float]:
        values = []
        for node in nodes:
            mol = node.mol.rdkit_mol
            
            # ä½¿ç”¨ Bertz å¤æ‚åº¦æŒ‡æ ‡
            from rdkit.Chem import GraphDescriptors
            complexity = GraphDescriptors.BertzCT(mol)
            
            # å½’ä¸€åŒ–åˆ° [0, 1]
            value = min(complexity / 1000.0, 1.0)
            values.append(value)
        
        return values

# ä½¿ç”¨è‡ªå®šä¹‰å€¼å‡½æ•°
custom_value_fn = MolecularComplexityValueFunction()

alg = RetroStarSearch(
    reaction_model=model,
    mol_inventory=inventory,
    or_node_cost_fn=retro_star.MolIsPurchasableCost(),
    and_node_cost_fn=ReactionModelLogProbCost(normalize=False),
    value_function=custom_value_fn,  # ä½¿ç”¨è‡ªå®šä¹‰å€¼å‡½æ•°
    limit_iterations=100,
    time_limit_s=60.0,
)
```

### è‡ªå®šä¹‰åŸæ–™åº“

```python
from syntheseus.search.mol_inventory import BaseMolInventory
from syntheseus import Molecule

class CustomInventory(BaseMolInventory):
    """è‡ªå®šä¹‰åŸæ–™åº“ï¼šåŸºäºè§„åˆ™åˆ¤æ–­å¯è´­ä¹°æ€§"""
    
    def __init__(self, max_atoms=15, max_rings=3):
        self.max_atoms = max_atoms
        self.max_rings = max_rings
    
    def is_purchasable(self, mol: Molecule) -> bool:
        rdkit_mol = mol.rdkit_mol
        
        # è§„åˆ™1: åŸå­æ•°ä¸è¶…è¿‡é˜ˆå€¼
        num_atoms = rdkit_mol.GetNumAtoms()
        if num_atoms > self.max_atoms:
            return False
        
        # è§„åˆ™2: ç¯æ•°ä¸è¶…è¿‡é˜ˆå€¼
        from rdkit.Chem import rdMolDescriptors
        num_rings = rdMolDescriptors.CalcNumRings(rdkit_mol)
        if num_rings > self.max_rings:
            return False
        
        return True

# ä½¿ç”¨è‡ªå®šä¹‰åŸæ–™åº“
custom_inventory = CustomInventory(max_atoms=12, max_rings=2)
print(f"æµ‹è¯•åˆ†å­å¯è´­ä¹°æ€§: {custom_inventory.is_purchasable(target)}")
```

### è‡ªå®šä¹‰æœç´¢ç®—æ³•

```python
from syntheseus.search.algorithms.base import AndOrSearchAlgorithm
from syntheseus.search.graph.and_or import AndOrGraph, OrNode

class DepthFirstSearch(AndOrSearchAlgorithm):
    """æ·±åº¦ä¼˜å…ˆæœç´¢å®ç°ç¤ºä¾‹"""
    
    def _run(self, graph: AndOrGraph):
        stack = [graph.root_node]
        
        while stack and not self._should_stop():
            # å–æ ˆé¡¶èŠ‚ç‚¹
            node = stack.pop()
            
            # è·³è¿‡å·²å±•å¼€æˆ–ä¸å¯å±•å¼€çš„èŠ‚ç‚¹
            if node.is_expanded or not self.can_expand_node(node, graph):
                continue
            
            # å±•å¼€èŠ‚ç‚¹
            newly_added = self.expand(node, graph)
            
            # å°†æ–°èŠ‚ç‚¹åŠ å…¥æ ˆ
            for new_node in newly_added:
                if isinstance(new_node, OrNode):
                    stack.append(new_node)
        
        return graph

# ä½¿ç”¨è‡ªå®šä¹‰ç®—æ³•
dfs_alg = DepthFirstSearch(
    reaction_model=model,
    mol_inventory=inventory,
    limit_iterations=100,
)
```

### é›†æˆå¤–éƒ¨æ•°æ®åº“

```python
# ä½¿ç”¨ PubChem æˆ– ChEMBL æ•°æ®
import requests

class PubChemInventory(BaseMolInventory):
    """åŸºäº PubChem çš„åŸæ–™åº“"""
    
    def is_purchasable(self, mol: Molecule) -> bool:
        # æŸ¥è¯¢ PubChem
        url = f"https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/smiles/{mol.smiles}/property/IsomericSMILES/JSON"
        try:
            response = requests.get(url, timeout=5)
            return response.status_code == 200
        except:
            return False
```

---

## å‘½ä»¤è¡Œå·¥å…·

Syntheseus æä¾›äº†å¼ºå¤§çš„å‘½ä»¤è¡Œæ¥å£ç”¨äºç”Ÿäº§ç¯å¢ƒã€‚

### è¿è¡Œæœç´¢

```bash
python -m syntheseus.cli.search \
    search_target="Cc1ccc(-c2ccc(C)cc2)cc1" \
    inventory_smiles_file=building_blocks.txt \
    model_class=LocalRetro \
    search_algorithm=retro_star \
    num_top_results=50 \
    time_limit_s=60 \
    limit_reaction_model_calls=100 \
    results_dir=./search_results \
    save_graph=true \
    num_routes_to_plot=5
```

### æ‰¹é‡æœç´¢

```bash
# targets.txt: æ¯è¡Œä¸€ä¸ª SMILES
python -m syntheseus.cli.search \
    search_targets_file=targets.txt \
    inventory_smiles_file=building_blocks.txt \
    model_class=LocalRetro \
    search_algorithm=retro_star \
    results_dir=./batch_results
```

### è¯„ä¼°å•æ­¥æ¨¡å‹

```bash
python -m syntheseus.cli.eval_single_step \
    model_class=LocalRetro \
    model_dir=/path/to/model \
    test_file=test_reactions.txt \
    output_file=predictions.pkl \
    num_results=50
```

### é…ç½®æ–‡ä»¶

å¯ä»¥ä½¿ç”¨ YAML é…ç½®æ–‡ä»¶ï¼š

```yaml
# config.yaml
search_algorithm: retro_star
model_class: LocalRetro
num_top_results: 50
time_limit_s: 60
limit_reaction_model_calls: 100

retro_star_config:
  max_expansion_depth: 10
  value_function_class: ConstantNodeEvaluator
  value_function_kwargs:
    constant: 0.0
  and_node_cost_fn_class: ReactionModelLogProbCost
  and_node_cost_fn_kwargs:
    normalize: false
```

ç„¶åè¿è¡Œï¼š

```bash
python -m syntheseus.cli.search \
    --config-name=config \
    search_target="Cc1ccc(-c2ccc(C)cc2)cc1" \
    inventory_smiles_file=building_blocks.txt
```

---

## å¸¸è§é—®é¢˜

### Q: å¦‚ä½•é€‰æ‹©åˆé€‚çš„æœç´¢ç®—æ³•ï¼Ÿ

**A**: 
- éœ€è¦æœ€ä¼˜è·¯å¾„ â†’ **Retro***
- éœ€è¦å¤šæ ·è·¯å¾„ â†’ **MCTS**
- å¿«é€ŸåŸå‹å¼€å‘ â†’ **BFS**
- å¤§è§„æ¨¡æœç´¢ â†’ **Retro*** (æ•ˆç‡æœ€é«˜)

### Q: æ¨¡å‹ä¸‹è½½å¾ˆæ…¢æˆ–å¤±è´¥æ€ä¹ˆåŠï¼Ÿ

**A**: 
1. æ‰‹åŠ¨ä¸‹è½½æ¨¡å‹åˆ° `~/.cache/torch/syntheseus/`
2. æˆ–è€…æŒ‡å®šæœ¬åœ°è·¯å¾„ï¼š
```python
model = LocalRetroModel(model_dir="/path/to/model")
```

### Q: å¦‚ä½•æé«˜æœç´¢é€Ÿåº¦ï¼Ÿ

**A**:
1. **å¯ç”¨ç¼“å­˜**: `use_cache=True`
2. **é™åˆ¶æœç´¢æ·±åº¦**: `max_expansion_depth=10`
3. **å‡å°‘æ¨¡å‹è°ƒç”¨**: `limit_reaction_model_calls=50`
4. **ä½¿ç”¨GPU**: `use_gpu=True`
5. **å‡å°‘è¿”å›ç»“æœæ•°**: `default_num_results=20`

### Q: æ‰¾ä¸åˆ°åˆæˆè·¯å¾„æ€ä¹ˆåŠï¼Ÿ

**A**:
1. **æ‰©å¤§åŸæ–™åº“**: ä½¿ç”¨æ›´å¤§çš„building blocksé›†åˆ
2. **å¢åŠ æœç´¢æ—¶é—´**: `time_limit_s=300`
3. **å¢åŠ æ¨¡å‹è°ƒç”¨æ¬¡æ•°**: `limit_reaction_model_calls=500`
4. **å°è¯•ä¸åŒç®—æ³•**: MCTSå¯èƒ½æ¯”Retro*æ‰¾åˆ°æ›´å¤šè·¯å¾„
5. **æ£€æŸ¥ç›®æ ‡åˆ†å­**: ç¡®ä¿SMILESæ ¼å¼æ­£ç¡®

### Q: å¦‚ä½•æ¯”è¾ƒä¸åŒæ¨¡å‹çš„æ€§èƒ½ï¼Ÿ

**A**:
```python
models = {
    "LocalRetro": LocalRetroModel(),
    "Chemformer": ChemformerModel(),
    "MEGAN": MEGANModel(),
}

for name, model in models.items():
    alg = RetroStarSearch(
        reaction_model=model,
        mol_inventory=inventory,
        # ... å…¶ä»–å‚æ•°ç›¸åŒ
    )
    # è¿è¡Œå¹¶æ¯”è¾ƒç»“æœ
```

### Q: å†…å­˜ä¸è¶³æ€ä¹ˆåŠï¼Ÿ

**A**:
1. **å‡å°æ‰¹å¤„ç†å¤§å°**: `batch_size=16`
2. **é™åˆ¶å›¾å¤§å°**: `limit_graph_nodes=10000`
3. **ä¸ä¿å­˜å®Œæ•´å›¾**: `save_graph=false`
4. **ä½¿ç”¨æ›´å°çš„æ¨¡å‹**: ä¾‹å¦‚ LocalRetro æ¯” Chemformer æ›´çœå†…å­˜

### Q: å¦‚ä½•å¯¼å‡ºåˆæˆè·¯å¾„ä¸ºå¯è¯»æ ¼å¼ï¼Ÿ

**A**:
```python
def export_route_to_text(route, graph):
    """å¯¼å‡ºè·¯å¾„ä¸ºæ–‡æœ¬æ ¼å¼"""
    from syntheseus.search.graph.and_or import AndNode, OrNode
    
    steps = []
    for node in route:
        if isinstance(node, AndNode):
            rxn = node.reaction
            product = rxn.product.smiles
            reactants = " + ".join([r.smiles for r in rxn.reactants])
            steps.append(f"{reactants} â†’ {product}")
    
    return "\n".join(steps)

# ä½¿ç”¨
with open("route.txt", "w") as f:
    f.write(export_route_to_text(routes[0], output_graph))
```

### Q: å¯ä»¥ç”¨äºæ­£å‘åˆæˆé¢„æµ‹å—ï¼Ÿ

**A**: Syntheseus ä¸»è¦è®¾è®¡ç”¨äºé€†åˆæˆã€‚å¯¹äºæ­£å‘åˆæˆé¢„æµ‹ï¼Œå»ºè®®ä½¿ç”¨ä¸“é—¨çš„æ­£å‘åˆæˆå·¥å…·ï¼Œæˆ–è€…ä½¿ç”¨ Syntheseus çš„å•æ­¥æ¨¡å‹æ¥å£å®ç°è‡ªå®šä¹‰æ­£å‘é¢„æµ‹ã€‚

### Q: å¦‚ä½•å¼•ç”¨ Syntheseusï¼Ÿ

**A**:
```bibtex
@article{maziarz2024re,
  title={Re-evaluating retrosynthesis algorithms with syntheseus},
  author={Maziarz, Krzysztof and Tripp, Austin and Liu, Guoqing and others},
  journal={Faraday Discussions},
  year={2024},
  publisher={Royal Society of Chemistry}
}
```

---

## æ›´å¤šèµ„æº

### æ–‡æ¡£å’Œæ•™ç¨‹

- ğŸ“– [å®˜æ–¹æ–‡æ¡£](https://microsoft.github.io/syntheseus/)
- ğŸ’» [GitHubä»“åº“](https://github.com/microsoft/syntheseus)
- ğŸ“ [è®ºæ–‡](https://pubs.rsc.org/en/content/articlelanding/2024/fd/d4fd00093e)
- ğŸ“ [ç¤ºä¾‹Notebooks](https://microsoft.github.io/syntheseus/stable/tutorials/quick_start/)

### ç¤¾åŒºå’Œæ”¯æŒ

- ğŸ’¬ [GitHub Issues](https://github.com/microsoft/syntheseus/issues)
- ğŸ“§ è”ç³»ä½œè€…

### ç›¸å…³é¡¹ç›®

- [Retro-fallback](https://github.com/AustinT/retro-fallback-iclr24) - å›é€€æœç´¢ç­–ç•¥
- [RetroGFN](https://github.com/gmum/RetroGFN) - ç”Ÿæˆæµç½‘ç»œæ–¹æ³•
- [SimpRetro](https://github.com/catalystforyou/SimpRetro) - ç®€åŒ–çš„é€†åˆæˆæ–¹æ³•

---

## æ›´æ–°æ—¥å¿—

æŸ¥çœ‹ [CHANGELOG.md](../CHANGELOG.md) äº†è§£æœ€æ–°æ›´æ–°ã€‚

---

## è®¸å¯è¯

Syntheseus é‡‡ç”¨ MIT è®¸å¯è¯ã€‚è¯¦è§ [LICENSE](../LICENSE)ã€‚

---

**ç¥ä½ ä½¿ç”¨æ„‰å¿«ï¼** ğŸš€

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œæ¬¢è¿åœ¨ GitHub ä¸Šæ Issue æˆ– PRã€‚
